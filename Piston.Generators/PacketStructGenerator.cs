using System.Text;
using System.Text.Json;
using Microsoft.CodeAnalysis;
using Piston.Generators.Entities;

namespace Piston.Generators;

[Generator]
public class PacketStructGenerator : ISourceGenerator
{
    private static readonly JsonSerializerOptions SerializerOptions = new()
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        DictionaryKeyPolicy = JsonNamingPolicy.CamelCase
    };

    private static readonly DiagnosticDescriptor JsonParsingError = new(
        "CODEGEN001", "Could not parse JSON file", "Could not parse \"Packets.json\" file", "PacketStructGenerator",
        DiagnosticSeverity.Error, true);

    public void Initialize(GeneratorInitializationContext context)
    {
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var packetListFile =
            context.AdditionalFiles.FirstOrDefault(file => Path.GetFileName(file.Path) == "Packets.json");
        if (packetListFile is null)
        {
            context.ReportDiagnostic(Diagnostic.Create(JsonParsingError, Location.None, Array.Empty<object>()));
            return;
        }

        var sourceText = packetListFile.GetText(context.CancellationToken);
        if (sourceText is null)
        {
            context.ReportDiagnostic(Diagnostic.Create(JsonParsingError, Location.None, Array.Empty<object>()));
            return;
        }

        var packetList = JsonSerializer.Deserialize<PacketList>(sourceText.ToString(), SerializerOptions);
        if (packetList is null)
        {
            context.ReportDiagnostic(Diagnostic.Create(JsonParsingError, Location.None, Array.Empty<object>()));
            return;
        }

        var allPackets = packetList.HandshakePackets!
            .Union(packetList.StatusPackets!)
            .Union(packetList.LoginPackets!)
            .Union(packetList.PlayPackets!);
        foreach (var definition in allPackets)
        {
            var source = new StringBuilder("// <auto-generated />\n");
            source.Append("namespace Piston.Networking;\n\n");
            source.AppendLine($"public record struct {definition.Name}Packet : IMessage<{definition.Name}Packet>");
            source.AppendLine("{");

            foreach (var field in definition.Fields!)
            {
                Span<char> fieldName = field.Key.ToCharArray();
                fieldName[0] = char.ToUpper(fieldName[0]);

                var type = ParseFieldType(field.Value);
                source.Indent(4).AppendFormat("public {0} {1} {{ get; init; }}\n", type, fieldName.ToString());
            }
            source.Append('\n');
            
            source.Indent(4).AppendLine("public void Write()");
            source.Indent(4).AppendLine("{");
            foreach (var field in definition.Fields!)
            {
                Span<char> fieldName = field.Key.ToCharArray();
                fieldName[0] = char.ToUpper(fieldName[0]);

                source.Indent(8).AppendFormat("// TODO: Write {0} to stream\n", fieldName.ToString());
            }
            source.Indent(4).AppendLine("}\n");
            
            source.Indent(4).AppendLine($"public static {definition.Name}Packet Read()");
            source.Indent(4).AppendLine("{");
            foreach (var field in definition.Fields!)
            {
                Span<char> fieldName = field.Key.ToCharArray();
                fieldName[0] = char.ToUpper(fieldName[0]);

                source.Indent(8).AppendFormat("// TODO: Read {0} from stream\n", fieldName.ToString());
            }
            source.Indent(8).AppendLine($"return new {definition.Name}Packet();");
            source.Indent(4).AppendLine("}");
            
            source.AppendLine("}");
            context.AddSource($"{definition.Name}Packet.g.cs", source.ToString());
        }
    }

    private static string ParseFieldType(string fieldValue)
    {
        return fieldValue switch
        {
            "bool" => "bool",
            "byte" => "byte",
            "sbyte" => "sbyte",
            "short" => "short",
            "ushort" => "ushort",
            "int" => "int",
            "long" => "long",
            "float" => "float",
            "double" => "double",
            "string" => "string",
            "varint" => "int",
            "varlong" => "long",
            _ => "object? /* ERROR */"
        };
    }
}